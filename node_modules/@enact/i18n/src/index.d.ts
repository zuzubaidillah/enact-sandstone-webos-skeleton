/**
 * Set CaseMapper object references to ilib's current locale (its most recently set, by default)
 */
function initCaseMappers(): void;
/**
 * Returns the current ilib.ResBundle
 */
function getResBundle(): ResBundle;
/**
 * Locale-safely convert a string to lower case.
 */
function toLowerCase(inString: string): string;
/**
 * Creates a new ilib.ResBundle for string translation
 */
function createResBundle(any, locale: Locale): Promise | ResBundle;

/**
 * Represents a binary buffer of unsigned bytes that will be parsed in various ways. The buffer
can be decoded by reading various lengths of bytes and interpreting them as longs
or unsigned bytes, etc. The bytes are interpreted in big-endian (network) format.
 */

declare class PackedBuffer {
  /**
 * Return the specified number of signed long integers from the current location in
the buffer as an array of numbers and advance the current pointer in the buffer.
This method will only return as many longs as are available in the rest of the
buffer.
 */
  getLongs(num: number): number[];
  /**
 * Return a signed long integer from the current location in
the buffer as an array of numbers and advance the current pointer in the buffer.
This method will only return a long if it is available in the buffer, otherwise
it will return undefined.
 */
  getLong(): number;
  /**
 * Return the specified number of signed byte integers from the current location in
the buffer as an array of numbers and advance the current pointer in the buffer.
This method will only return as many bytes as are available in the rest of the
buffer.
 */
  getBytes(num: number | void): number[];
  /**
 * Return a signed byte integer from the current location in
the buffer as an array of numbers and advance the current pointer in the buffer.
This method will only return a byte if it is available in the buffer, otherwise
it will return undefined.
 */
  getByte(): number;
  /**
 * Return the specified number of unsigned byte integers from the current location in
the buffer as an array of numbers and advance the current pointer in the buffer.
This method will only return as many bytes as are available in the rest of the
buffer.
 */
  getUnsignedBytes(num: number): number[];
  /**
 * Return a string made out of the given number of bytes and convert
from UTF-8 to UTF-16.
 */
  getString(num: number): string;
  /**
 * Advance the current pointer in the buffer by the specified number of
bytes in the string.
 */
  skip(num: number): void;
}

/**
 * Locale-safely convert a string to upper case.
 */
function toUpperCase(inString: string): string;
/**
 * Set the locale for the strings that $L loads. This may reload the
string resources if necessary.
 */
function setResBundle(any, spec: string): ResBundle;
/**
 * Deletes the current bundle object of strings and clears the cache.
 */
function clearResBundle(): void;

/**
 * Represents a binary zone info file of the sort that the Unix Zone Info Compiler
produces.
 */

declare class ZoneInfoFile {
  /**
 * Binary search a sorted array of numbers for a particular target value.
If the exact value is not found, it returns the index of the largest
entry that is smaller than the given target value. <p>
 */
  bsearch(target: number, arr: Array<any>): number;
  /**
   * Return whether or not this zone uses DST in the given year.
   */
  usesDST(date: Date): boolean;
  /**
   * Return the raw offset from UTC that this zone uses at the given time.
   */
  getRawOffset(date: Date): number;
  /**
 * If this zone uses DST in the given year, return the DST savings
in use. If the zone does not use DST in the given year, this
method will return 0.
 */
  getDSTSavings(date: Date): number;
  /**
 * Return the start date/time of DST if this zone uses
DST in the given year.
 */
  getDSTStartDate(date: Date): number;
  /**
 * Return the end date/time of DST if this zone uses
DST in the given year.
 */
  getDSTEndDate(date: Date): number;
  /**
 * Return the abbreviation used by this zone in standard
time.
 */
  getAbbreviation(date: Date): string;
  /**
 * Return the abbreviation used by this zone in daylight
time. If the zone does not use DST in the given year,
this returns the same thing as getAbbreviation().
 */
  getDSTAbbreviation(date: Date): string;
  /**
 * Return the zone information for the given date in ilib
format.
 */
  getIlibZoneInfo(date: Date): object;
}

/**
 * Retrieves an IString from a resource bundle by key.
 *
 * If the bundle doesn't exist, the key is returned wrapped by IString.
 */
function getIStringFromBundle(str: string | object, rb: ResBundl): IString;
/**
 * Load the list of files asynchronously. This uses recursion in
order to create a queue of files that will be loaded serially.
Each layer, starting at the bottom, loads a file and then loads
the layer on top of it. The very top file on the stack will have
zero files to load, so instead it will be the one to call the
callback to notify the caller that all the content is loaded.
 */
function _loadFilesAsync(
  any,
  params: object,
  any,
  any,
  paths: string[],
  results: Array<any>,
  callback: any,
): Promise;
