"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dragConfigPropType = exports.defaultDragConfig = exports["default"] = exports.Drag = void 0;
var _clamp = _interopRequireDefault(require("ramda/src/clamp"));
var _propTypes = _interopRequireDefault(require("prop-types"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var Tracking = {
  Untracked: 0,
  Active: 1,
  Paused: 2
};
var Drag = exports.Drag = /*#__PURE__*/_createClass(function Drag() {
  var _this = this;
  _classCallCheck(this, Drag);
  this.dragConfig = null;
  this.isDragging = function () {
    return _this.dragConfig != null;
  };
  this.setContainerBounds = function (node) {
    var _this$dragConfig = _this.dragConfig,
      isGlobal = _this$dragConfig.global,
      boxSizing = _this$dragConfig.boxSizing;
    var bounds = null;
    if (!node) return;
    if (isGlobal) {
      bounds = {
        minX: 0,
        minY: 0,
        maxX: window.innerWidth,
        maxY: window.innerHeight
      };
    } else {
      bounds = node.getBoundingClientRect();

      // adjust for padding when using content-box
      if (boxSizing === 'content-box') {
        var computedStyle = window.getComputedStyle(node);
        bounds = {
          minX: bounds.left + parseInt(computedStyle.paddingLeft),
          minY: bounds.top + parseInt(computedStyle.paddingTop),
          maxX: bounds.right - parseInt(computedStyle.paddingRight),
          maxY: bounds.bottom - parseInt(computedStyle.paddingBottom)
        };
      }
    }
    _this.bounds = bounds;
  };
  this.updatePosition = function (clientX, clientY) {
    var _this$bounds = _this.bounds,
      maxX = _this$bounds.maxX,
      maxY = _this$bounds.maxY,
      minX = _this$bounds.minX,
      minY = _this$bounds.minY;
    var x = (0, _clamp["default"])(minX, maxX, clientX) - minX;
    var y = (0, _clamp["default"])(minY, maxY, clientY) - minY;
    if (x !== _this.x || y !== _this.y) {
      _this.x = x;
      _this.y = y;
      return true;
    }
    return false;
  };
  this.begin = function (config, _ref, coords, node) {
    var noResume = _ref.noResume,
      onDrag = _ref.onDrag,
      onDragEnd = _ref.onDragEnd,
      onDragStart = _ref.onDragStart;
    if (!onDrag && !onDragStart && !onDragEnd) return;
    var x = coords.x,
      y = coords.y;
    _this.tracking = Tracking.Untracked;
    _this.startX = x;
    _this.startY = y;
    _this.dragConfig = _objectSpread(_objectSpread({}, config), {}, {
      node: node,
      resume: !noResume
    });
    _this.onDrag = onDrag;
    _this.onDragStart = onDragStart;
    _this.onDragEnd = onDragEnd;
    _this.setContainerBounds(node);
    _this.move(coords);
  };
  // This method will get the `onDrag`, `onDragEnd`, `onDragStart` props.
  this.updateProps = function (_ref2) {
    var onDrag = _ref2.onDrag,
      onDragEnd = _ref2.onDragEnd,
      onDragStart = _ref2.onDragStart;
    // Check `isDragging` gesture is not in progress. Check if gesture exists before updating the references to the `dragConfig`
    if (!_this.isDragging()) return;

    // This will update the `dragConfig` with the new value
    _this.onDrag = onDrag;
    _this.onDragStart = onDragStart;
    _this.onDragEnd = onDragEnd;
  };
  this.move = function (coords) {
    if (!_this.isDragging()) return;
    var moveTolerance = _this.dragConfig.moveTolerance;
    if (_this.tracking === Tracking.Untracked) {
      var dx = coords.x - _this.startX;
      var dy = coords.y - _this.startY;
      if (Math.sqrt(dx * dx + dy * dy) >= moveTolerance) {
        _this.tracking = Tracking.Active;
        if (_this.onDragStart) {
          _this.onDragStart(_objectSpread({
            type: 'onDragStart'
          }, coords));
        }
      }
    } else if (_this.onDrag && _this.tracking === Tracking.Active && _this.updatePosition(coords)) {
      _this.onDrag(_objectSpread({
        type: 'onDrag'
      }, coords));
    }
  };
  this.blur = function () {
    if (!_this.isDragging()) return;
    if (!_this.dragConfig.global) {
      _this.end();
    }
  };
  this.end = function () {
    if (!_this.isDragging()) return;
    if (_this.onDragEnd && _this.tracking !== Tracking.Untracked) {
      _this.onDragEnd({
        type: 'onDragEnd'
      });
    }
    _this.tracking = Tracking.Untracked;
    _this.dragConfig = null;
  };
  this.enter = function () {
    if (!_this.isDragging()) return;
    if (_this.dragConfig.resume && _this.tracking === Tracking.Paused) {
      _this.tracking = Tracking.Active;
    }
  };
  this.leave = function () {
    if (!_this.isDragging()) return;
    if (!_this.dragConfig.global && _this.tracking === Tracking.Active) {
      _this.tracking = Tracking.Paused;
    }
  };
});
var defaultDragConfig = exports.defaultDragConfig = {
  boxSizing: 'border-box',
  global: false,
  moveTolerance: 16
};
var dragConfigPropType = exports.dragConfigPropType = _propTypes["default"].shape({
  boxSizing: _propTypes["default"].string,
  global: _propTypes["default"].bool,
  moveTolerance: _propTypes["default"].number
});
var _default = exports["default"] = Drag;