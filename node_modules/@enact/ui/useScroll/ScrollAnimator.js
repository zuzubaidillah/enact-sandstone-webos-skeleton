"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.ScrollAnimator = void 0;
var _util = require("@enact/core/util");
var _clamp = _interopRequireDefault(require("ramda/src/clamp"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var
  // Use eases library
  timingFunctions = {
    'linear': function linear(source, target, duration, curTime) {
      curTime /= duration;
      return (target - source) * curTime + source;
    },
    'ease-in': function easeIn(source, target, duration, curTime) {
      curTime /= duration;
      return (target - source) * curTime * curTime * curTime * curTime + source;
    },
    'ease-out': function easeOut(source, target, duration, curTime) {
      curTime /= duration;
      curTime--;
      return (target - source) * (curTime * curTime * curTime * curTime * curTime + 1) + source;
    },
    'ease-in-out': function easeInOut(source, target, duration, curTime) {
      curTime /= duration / 2;
      if (curTime < 1) {
        return (target - source) / 2 * curTime * curTime * curTime * curTime + source;
      } else {
        curTime -= 2;
      }
      return (source - target) / 2 * (curTime * curTime * curTime * curTime - 2) + source;
    }
  },
  // for simulate()
  frameTime = 16.0,
  // time for one frame
  maxVelocity = 100,
  // speed cap
  stopVelocity = 0.04,
  // velocity to stop
  velocityFriction = 0.95,
  // velocity decreasing factor
  clampVelocity = (0, _clamp["default"])(-maxVelocity, maxVelocity);

/**
 * The class to scroll a list or a scroller with animation.
 *
 * @class ScrollAnimator
 * @memberof ui/useScroll
 * @private
 */
var ScrollAnimator = exports.ScrollAnimator = /*#__PURE__*/function () {
  /**
   * @param {String|null} type - Timing function type for list scroll animation.  Must be one of
   *	`'linear'`, `'ease-in'`, `'ease-out'`, or `'ease-in-out'`, or null. If `null`, defaults to
   *	`'ease-out'`.
   * @constructor
   * @memberof ui/useScroll.ScrollAnimator
   */
  function ScrollAnimator(type) {
    _classCallCheck(this, ScrollAnimator);
    this.rAFId = null;
    this.type = 'ease-out';
    this.timingFunction = timingFunctions[type || this.type];
  }
  _createClass(ScrollAnimator, [{
    key: "simulate",
    value: function simulate(sourceX, sourceY, velocityX, velocityY) {
      var stepX = clampVelocity(velocityX * frameTime),
        stepY = clampVelocity(velocityY * frameTime),
        deltaX = 0,
        deltaY = 0,
        duration = 0;
      do {
        stepX *= velocityFriction;
        stepY *= velocityFriction;
        deltaX += stepX;
        deltaY += stepY;
        duration += frameTime;
      } while (stepX * stepX + stepY * stepY > stopVelocity);
      return {
        targetX: sourceX + deltaX,
        targetY: sourceY + deltaY,
        duration: duration
      };
    }
  }, {
    key: "animate",
    value: function animate(rAFCallbackFuntion) {
      var _this = this;
      var rAF = window.requestAnimationFrame,
        startTimeStamp = (0, _util.perfNow)(),
        fn = function fn() {
          var
            // schedule next frame
            rAFId = rAF(fn),
            // current timestamp
            curTimeStamp = (0, _util.perfNow)(),
            // current time if 0 at starting position
            curTime = curTimeStamp - startTimeStamp;
          _this.rAFId = rAFId;
          rAFCallbackFuntion(curTime);
        };
      this.rAFId = rAF(fn);
    }
  }, {
    key: "isAnimating",
    value: function isAnimating() {
      return this.rAFId !== null;
    }
  }, {
    key: "stop",
    value: function stop() {
      var cAF = window.cancelAnimationFrame;
      if (this.rAFId !== null) {
        cAF(this.rAFId);
        this.rAFId = null;
      }
    }
  }]);
  return ScrollAnimator;
}();
var _default = exports["default"] = ScrollAnimator;