"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNavigableTarget = getNavigableTarget;
exports.getNearestTargetFromPosition = void 0;
exports.getTargetByContainer = getTargetByContainer;
exports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;
exports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;
exports.getTargetBySelector = getTargetBySelector;
exports.isFocusable = isFocusable;
var _clamp = _interopRequireDefault(require("ramda/src/clamp"));
var _last = _interopRequireDefault(require("ramda/src/last"));
var _container = require("./container");
var _navigate = _interopRequireDefault(require("./navigate"));
var _utils = require("./utils");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function isFocusable(elem) {
  var containers = (0, _container.getContainersForNode)(elem);
  var verifySelector = true;
  for (var i = containers.length - 1; i >= 0; i--) {
    var containerId = containers[i];
    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {
      return false;
    }

    // only verify selector for the first (immediate ancestor) container
    verifySelector = false;
  }
  return true;
}
function getContainersToSearch(containerId) {
  var range = [];
  var addRange = function addRange(id) {
    var config = (0, _container.getContainerConfig)(id);
    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {
      range.push(id);
    }
  };
  if (containerId) {
    addRange(containerId);
  } else {
    addRange((0, _container.getDefaultContainer)());
    addRange((0, _container.getLastContainer)());
    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);
  }
  return range;
}
function getTargetByContainer(containerId, enterTo) {
  return getContainersToSearch(containerId).reduce(function (next, id) {
    return next || (0, _container.getContainerFocusTarget)(id, enterTo);
  }, null);
}
function getTargetBySelector(selector) {
  if (!selector) return null;
  if (selector.charAt(0) === '@') {
    var containerId = selector.length === 1 ? null : selector.substr(1);
    return getTargetByContainer(containerId);
  }
  var next = (0, _utils.parseSelector)(selector)[0];
  if (next) {
    if ((0, _container.isContainer)(next)) {
      return getTargetByContainer((0, _container.getContainerId)(next));
    }
    var nextContainerIds = (0, _container.getContainersForNode)(next);
    if ((0, _container.isNavigable)(next, (0, _last["default"])(nextContainerIds), true)) {
      return next;
    }
  }
  return null;
}
function isRestrictedContainer(containerId) {
  var config = (0, _container.getContainerConfig)(containerId);
  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');
}
function filterRects(elementRects, boundingRect) {
  if (!boundingRect) {
    return elementRects;
  }

  // remove elements that are outside of boundingRect, if specified
  return elementRects.filter(function (rect) {
    if ((0, _container.isContainer)(rect.element)) {
      // For containers, test intersection since they may be larger than the bounding rect
      return (0, _utils.intersects)(boundingRect, rect);
    } else {
      // For elements, use contains with the center to include mostly visible elements
      return (0, _utils.contains)(boundingRect, rect.center);
    }
  }).map(function (rect) {
    var topUpdate = rect.top < boundingRect.top;
    var bottomUpdate = rect.bottom > boundingRect.bottom;
    var leftUpdate = rect.left < boundingRect.left;
    var rightUpdate = rect.right > boundingRect.right;

    // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and
    // recalculate the center based on the new bounds.
    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {
      var updated = _objectSpread(_objectSpread({}, rect), {}, {
        center: _objectSpread({}, rect.center)
      });
      if (topUpdate) updated.top = boundingRect.top;
      if (bottomUpdate) updated.bottom = boundingRect.bottom;
      if (leftUpdate) updated.left = boundingRect.left;
      if (rightUpdate) updated.right = boundingRect.right;
      if (leftUpdate || rightUpdate) {
        var centerX = updated.left + (updated.right - updated.left) / 2;
        updated.center.x = updated.center.left = updated.center.right = centerX;
      }
      if (topUpdate || bottomUpdate) {
        var centerY = updated.top + (updated.bottom - updated.top) / 2;
        updated.center.y = updated.center.top = updated.center.bottom = centerY;
      }
      return updated;
    }
    return rect;
  });
}
function getContainerContainingRect(elementRects, elementRect) {
  // find candidates that are containers and *visually* contain element
  var overlapping = elementRects.filter(function (rect) {
    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);
  });

  // if the next element is a container AND the current element is *visually* contained within
  // one of the candidate element, we need to ignore container `enterTo` preferences and
  // retrieve its spottable descendants and try to navigate to them.
  if (overlapping.length) {
    return overlapping[0].element.dataset.spotlightId;
  }
  return false;
}
function getOverflowContainerRect(containerId) {
  // if the target container has overflowing content, update the boundingRect to match its
  // bounds to prevent finding elements within the container's hierarchy but not visible.
  // This filter only applies when waterfalling to prevent filtering out elements that share
  // a container tree with `element`
  var nextConfig = (0, _container.getContainerConfig)(containerId);
  if (nextConfig && nextConfig.overflow) {
    return (0, _utils.getContainerRect)(containerId);
  }
}
function getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {
  var elements = (0, _container.getDeepSpottableDescendants)(containerId);
  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);
  var next = null;
  var _loop = function _loop() {
      var overlappingContainerId = getContainerContainingRect(elementRects, positionRect);

      // if the pointer is within a container that is a candidate element, we need to ignore container
      // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.
      if (overlappingContainerId) {
        next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);
        if (!next) {
          // filter out the container and try again
          elementRects = elementRects.filter(function (rect) {
            return rect.element.dataset.spotlightId !== overlappingContainerId;
          });
          return 0; // continue
        }

        // found a target so break out and return
        return 1; // break
      }

      // try to navigate from position to one of the candidates in containerId
      next = (0, _navigate["default"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId));

      // if we match a container, recurse into it
      if (next && (0, _container.isContainer)(next)) {
        var nextContainerId = next.dataset.spotlightId;

        // need to cache this reference so we can filter it out later if necessary
        var lastNavigated = next;
        next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);
        if (!next) {
          // filter out the container and try again
          elementRects = elementRects.filter(function (rect) {
            return rect.element !== lastNavigated;
          });
          return 0; // continue
        }
      }

      // If we've met every condition and haven't explicitly retried the search via `continue`,
      // break out and return
      return 1; // break
    },
    _ret;
  while (elementRects.length > 0) {
    _ret = _loop();
    if (_ret === 0) continue;
    if (_ret === 1) break;
  }
  return next;
}
function getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {
  var elements = (0, _container.getDeepSpottableDescendants)(containerId);

  // shortcut for previous target from element if it were saved
  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);
  if (previous && elements.indexOf(previous) !== -1) {
    return previous;
  }

  // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an
  // spotlight container with `overflow: true` to be treated as if it were outside of the
  // container. The result is that the candidates, `elements` are filtered by the bounds of the
  // overflow container effectively hiding those that have overflowed and are visually hidden.
  //
  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to
  // escape the Scrollable from paging controls rather than focusing contents that are out of view
  if (element.dataset.spotlightOverflow === 'ignore') {
    boundingRect = getOverflowContainerRect(containerId) || boundingRect;
  }
  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);
  var next = null;
  var _loop2 = function _loop2() {
      var overlappingContainerId = getContainerContainingRect(elementRects, elementRect);

      // if the next element is a container AND the current element is *visually* contained within
      // one of the candidate elements, we need to ignore container `enterTo` preferences and
      // retrieve its spottable descendants and try to navigate to them.
      if (overlappingContainerId) {
        next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);
        if (!next) {
          // filter out the container and try again
          elementRects = elementRects.filter(function (rect) {
            return rect.element.dataset.spotlightId !== overlappingContainerId;
          });
          return 0; // continue
        }

        // found a target so break out and return
        return 1; // break
      }

      // If one of the downstream containers is configured for partition, we use that
      // container's bounds as the partition rect for navigation.
      var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {
        var cfg = (0, _container.getContainerConfig)(id);
        return cfg && cfg.partition;
      });
      var partitionRect = elementRect;
      if (partitionContainer) {
        partitionRect = (0, _utils.getContainerRect)(partitionContainer);
      }

      // try to navigate from element to one of the candidates in containerId
      next = (0, _navigate["default"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect);

      // if we match a container,
      if (next && (0, _container.isContainer)(next)) {
        var nextContainerId = next.dataset.spotlightId;

        // need to cache this reference so we can filter it out later if necessary
        var lastNavigated = next;

        // and it is restricted, return its target
        if (isRestrictedContainer(nextContainerId)) {
          next = getTargetByContainer(nextContainerId);
        } else {
          // otherwise, recurse into it
          next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);
        }
        if (!next) {
          elementRects = elementRects.filter(function (rect) {
            return rect.element !== lastNavigated;
          });
          return 0; // continue
        }
      }

      // If we've met every condition and haven't explicitly retried the search via `continue`,
      // break out and return
      return 1; // break
    },
    _ret2;
  while (elementRects.length > 0) {
    _ret2 = _loop2();
    if (_ret2 === 0) continue;
    if (_ret2 === 1) break;
  }
  return next;
}
function getTargetByDirectionFromElement(direction, element) {
  var _getContainerConfig;
  var getIntersectRectOfElem = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var extSelector = element.getAttribute('data-spot-' + direction);
  if (typeof extSelector === 'string') {
    return getTargetBySelector(extSelector);
  }
  var elementContainerId = (0, _container.getContainersForNode)(element).pop();
  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {
    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, getIntersectRectOfElem ? (0, _utils.getIntersectionRect)((0, _container.getContainerNode)(elementContainerId), element) : (0, _utils.getRect)(element), elementContainerIds);
    if (!result) {
      result = getLeaveForTarget(containerId, direction);

      // To support a `leaveFor` configuration with navigation disallowed in the current
      // `direction`, we return the current element to prevent further searches for a
      // target in this reduction.
      if (result === false) {
        result = element;
      }
    }
    return result;
  }, null);

  // If the reduce above returns the original element,
  // check if the element is clipped by an overflow container. If true, find the target by direction with the intersection rect of the element.
  // If the reduce above returns the original element again, it means it hit a `leaveFor` config that
  // prevents navigation so we enforce that here by returning null.
  if (next !== element) {
    return next;
  } else if (elementContainerId !== _container.rootContainerId && (_getContainerConfig = (0, _container.getContainerConfig)(elementContainerId)) !== null && _getContainerConfig !== void 0 && _getContainerConfig.overflow && !getIntersectRectOfElem) {
    return getTargetByDirectionFromElement(direction, element, true);
  } else {
    return null;
  }
}
function getTargetByDirectionFromPosition(direction, position, containerId) {
  var pointerRect = (0, _utils.getPointRect)(position);
  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {
    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);
  }, null);
}

/**
 * Returns the target identified by the selector configured for the container identified by
 * `containerId` for the given `direction`. If the selector is an empty string, the method returns
 * `false` indicating that navigation isn't allowed out of the container in that direction.
 *
 * @param   {String}        containerId  Identifier for a container
 * @param   {String}        direction    Direction to navigate (up, down, left, right)
 *
 * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed
 * @private
 */
function getLeaveForTarget(containerId, direction) {
  var config = (0, _container.getContainerConfig)(containerId);
  if (config) {
    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];
    if (typeof target === 'string') {
      if (target === '') {
        return false;
      }
      return getTargetBySelector(target);
    }
    var nextContainerIds = (0, _container.getContainersForNode)(target);
    if ((0, _container.isNavigable)(target, (0, _last["default"])(nextContainerIds))) {
      return target;
    }
  }
  return null;
}
function getNavigableTarget(target) {
  if (target === document) return null;
  var parent;
  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {
    parent = target.parentNode;
    target = parent === document ? null : parent; // calling isNavigable on document is problematic
  }
  return target;
}
var getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {
  var x = _ref.x,
    y = _ref.y;
  var left = _ref2.left,
    right = _ref2.right,
    top = _ref2.top,
    bottom = _ref2.bottom;
  if (direction === 'left' || direction === 'right') {
    if (y > bottom) {
      distance += y - bottom;
    } else if (y < top) {
      distance += top - y;
    }
  } else if (x > right) {
    distance += x - right;
  } else if (x < left) {
    distance += left - x;
  }
  return distance;
};
var getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {
  var x = position.x,
    y = position.y;
  var distance;
  if (direction === 'left') {
    distance = x - elementRect.right;
  } else if (direction === 'right') {
    distance = elementRect.left - x;
  } else if (direction === 'up') {
    distance = y - elementRect.bottom;
  } else if (direction === 'down') {
    distance = elementRect.top - y;
  }
  return getOffsetDistanceToTargetFromPosition((0, _clamp["default"])(0, Math.abs(distance), distance), direction, position, elementRect);
};
var getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {
  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {
    var target = getTargetByDirectionFromPosition(direction, position, containerId);
    if (target) {
      result.push({
        direction: direction,
        target: target
      });
    }
    return result;
  }, []);
};
var getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {
  var targets = getNearestTargetsInContainerFromPosition(position, containerId);
  if (!targets.length) {
    return;
  }
  targets.forEach(function (item) {
    var direction = item.direction,
      target = item.target;
    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));
  });
  targets.sort(function (a, b) {
    return a.distance - b.distance;
  });
  return targets[0].target;
};
var getNearestTargetFromPosition = exports.getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {
  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);
};