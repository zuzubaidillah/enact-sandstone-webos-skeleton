{"version":3,"names":["ruleComposer","require","eslint","rule","Linter","getRules","get","isFinalStatementInBlockStatement","node","parent","test","type","body","length","isInDoStatement","isOptionalCallExpression","expression","module","exports","filterReports","problem"],"sources":["../../src/rules/no-unused-expressions.cjs"],"sourcesContent":["const ruleComposer = require(\"eslint-rule-composer\");\nconst eslint = require(\"eslint\");\n\nconst rule = new eslint.Linter().getRules().get(\"no-unused-expressions\");\n\n/**\n * @param {ASTNode} node - any node\n * @returns {boolean} whether the given node is either an IfStatement or an\n *   ExpressionStatement and is the last node in the body of a BlockStatement\n */\nfunction isFinalStatementInBlockStatement(node) {\n  const parent = node.parent;\n  return (\n    /^(?:If|Expression)Statement$/.test(node.type) &&\n    parent.type === \"BlockStatement\" &&\n    parent.body[parent.body.length - 1] === node\n  );\n}\n\n/**\n * @param {ASTNode} node - any node\n * @returns {boolean} whether the given node represents an unbroken chain of\n *   tail ExpressionStatements and IfStatements within a DoExpression\n * https://github.com/tc39/proposal-do-expressions\n */\nfunction isInDoStatement(node) {\n  if (!node) return false;\n\n  if (node.type === \"DoExpression\") return true;\n\n  // this is an `else if`\n  if (\n    node.type === \"IfStatement\" &&\n    node.parent &&\n    node.parent.type === \"IfStatement\"\n  ) {\n    return isInDoStatement(node.parent);\n  }\n\n  if (isFinalStatementInBlockStatement(node)) {\n    return isInDoStatement(node.parent.parent);\n  }\n\n  return false;\n}\n\n/**\n * @param {ASTNode} node - any node\n * @returns {boolean} whether the given node is an optional call expression,\n * https://github.com/tc39/proposal-optional-chaining\n */\nfunction isOptionalCallExpression(node) {\n  return (\n    !!node &&\n    node.type === \"ExpressionStatement\" &&\n    node.expression.type === \"ChainExpression\" &&\n    node.expression.expression.type === \"CallExpression\"\n  );\n}\n\nmodule.exports = ruleComposer.filterReports(\n  rule,\n  problem =>\n    !isInDoStatement(problem.node) && !isOptionalCallExpression(problem.node),\n);\n"],"mappings":"AAAA,MAAMA,YAAY,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AACpD,MAAMC,MAAM,GAAGD,OAAO,CAAC,QAAQ,CAAC;AAEhC,MAAME,IAAI,GAAG,IAAID,MAAM,CAACE,MAAM,CAAC,CAAC,CAACC,QAAQ,CAAC,CAAC,CAACC,GAAG,CAAC,uBAAuB,CAAC;AAOxE,SAASC,gCAAgCA,CAACC,IAAI,EAAE;EAC9C,MAAMC,MAAM,GAAGD,IAAI,CAACC,MAAM;EAC1B,OACE,8BAA8B,CAACC,IAAI,CAACF,IAAI,CAACG,IAAI,CAAC,IAC9CF,MAAM,CAACE,IAAI,KAAK,gBAAgB,IAChCF,MAAM,CAACG,IAAI,CAACH,MAAM,CAACG,IAAI,CAACC,MAAM,GAAG,CAAC,CAAC,KAAKL,IAAI;AAEhD;AAQA,SAASM,eAAeA,CAACN,IAAI,EAAE;EAC7B,IAAI,CAACA,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACG,IAAI,KAAK,cAAc,EAAE,OAAO,IAAI;EAG7C,IACEH,IAAI,CAACG,IAAI,KAAK,aAAa,IAC3BH,IAAI,CAACC,MAAM,IACXD,IAAI,CAACC,MAAM,CAACE,IAAI,KAAK,aAAa,EAClC;IACA,OAAOG,eAAe,CAACN,IAAI,CAACC,MAAM,CAAC;EACrC;EAEA,IAAIF,gCAAgC,CAACC,IAAI,CAAC,EAAE;IAC1C,OAAOM,eAAe,CAACN,IAAI,CAACC,MAAM,CAACA,MAAM,CAAC;EAC5C;EAEA,OAAO,KAAK;AACd;AAOA,SAASM,wBAAwBA,CAACP,IAAI,EAAE;EACtC,OACE,CAAC,CAACA,IAAI,IACNA,IAAI,CAACG,IAAI,KAAK,qBAAqB,IACnCH,IAAI,CAACQ,UAAU,CAACL,IAAI,KAAK,iBAAiB,IAC1CH,IAAI,CAACQ,UAAU,CAACA,UAAU,CAACL,IAAI,KAAK,gBAAgB;AAExD;AAEAM,MAAM,CAACC,OAAO,GAAGlB,YAAY,CAACmB,aAAa,CACzChB,IAAI,EACJiB,OAAO,IACL,CAACN,eAAe,CAACM,OAAO,CAACZ,IAAI,CAAC,IAAI,CAACO,wBAAwB,CAACK,OAAO,CAACZ,IAAI,CAC5E,CAAC"}